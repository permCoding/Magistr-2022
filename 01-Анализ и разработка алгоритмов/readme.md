# Анализ алгоритмов

[Рейтинг ПИм-1 2023](https://docs.google.com/spreadsheets/d/1VUNMgV9Mk57zTohcsL_T9XbqyR1N8YigGRILlnrxdUQ/edit?usp=sharing)  

## Анализ сложности алгоритмов

## Алгоритмы сортировки  

[Блокнот 1 - Ассимптотики](https://colab.research.google.com/drive/1Cwn_ZQjUEmln24_cfNLlTJ9AF8bZ0OOX?usp=sharing)  

[Доска для рисования 2023 - Алгоритмы поиска](https://jamboard.google.com/d/1vtwRSDglO_TcvXbpGJEq9rlKMU_sOyvbBmXsc76kkY8/edit?usp=sharing)  

[Доска для рисования 2022 - Алгоритмы поиска](https://jamboard.google.com/d/1vtwRSDglO_TcvXbpGJEq9rlKMU_sOyvbBmXsc76kkY8/edit?usp=sharing)  

[Схемы алгоритмов](https://jamboard.google.com/d/1olktw4v8ZJbPNJQAhofzNWkwG8RRgzYtAhgQvSSJM4o/edit?usp=sharing)  

---  

**Практические вопросы:**  

- сортировка вставками  
- сортировка выбором  
- сортировка пузырьковая  
- сортировка шейкерная  
- рекурсия  
  - факториал  
  - Фибоначчи (наивно, с кэшем, итеративно)  
- сортировка быстрая (filter, append)  
- сортировка слиянием  
- пирамидальная  
- сортировка подсчётом  
- графики функций  

**Поиск, бинарный поиск, тернарный поиск, Золотое сечение, интерполяционный**  

- в массиве, в отсортированном массиве, на графике  

---  

### ЗАДАНИЯ ДЛЯ САМОСТОЯТЕЛЬНОГО ИСПОЛНЕНИЯ  

**ЛАБРАБ01**  
РЕКУРСИЯ  

- Напишите рекурсивную функцию перевода из десятичного числа в двоичное  
- Напишите рекурсивную функцию перевода из двоичного числа в десятичное  

---  

**ЛАБРАБ 02**  
СОРТИРОВКА  

***Сортировка вставками***  

> Разработать функцию сортировки списка вставками  
> Провести эксперимент - как растёт время сортировки при росте количества элементов n  
> В своём репозитории с помощью разметки markdown создать краткое описание вашей функции сортировки  
> В описание добавить таблицу с данными роста времени исполнения с помощью специальной разметки markdown

---  

**ЛАБРАБ 03**  
СОРТИРОВКА  

***Сортировка выбором и пузырьковая***  

> Разработать функцию сортировки списка выбором  
> Разработать функцию сортировки списка пузырьком  
> Провести эксперимент - как растёт время сортировки при росте количества элементов n  
> Сравнить сортировки: вставкой, выбором, пузырьком  
> В своём репозитории с помощью разметки markdown создать краткое описание вашей функции сортировки выбором  
> В описание добавить сводную таблицу с данными роста времени исполнения перечисленных функций сортировки  
> рекомендуемые названия функций: sort_bubble, sort_insert, sort_select  

---  

## Как собрать данные с нескольких функций сортировки на списках разной длины

Пример:  
> назначаем значение максимальной длины списка (max_count) для сортировки  
> генерируем список случайных элементов этой длины  
> запускаем цикл для изменения количества элементов в неотсортированном списке с шагом, например, 1000  
> на каждой итерации делаем срезы (lst1, lst2) из исходного неотсортированного списка  
> длина этих срезов на каждой итерации увеличивается на 1000 - чтобы провести испытания на списках разной длины  
> на каждой итерации по отдельности запускаем измерение продолжительности работы функций сортировки  
> получаемые данные выводим на экран  

Пример оформления программы:  

```py
import timeit 
import algo_sort as m


max_count = 10000
lst = m.get_lst(max_count)

for count in range(1000, max_count+1, 1000):
    
    lst1 = lst[:count+1]
    lst2 = lst[:count+1]

    start_time = timeit.default_timer() 
    m.sort_bubble(lst1)
    res1 = timeit.default_timer() - start_time
    
    start_time = timeit.default_timer() 
    m.sort_select(lst2)
    res2 = timeit.default_timer() - start_time
    
    print(f"{count}\t{round(res1, 2)}\t{round(res2, 2)}")
```

Пример результатов её работы:  

```txt
1000    0.1     0.09
2000    0.38    0.36
3000    0.79    0.8
4000    1.41    1.42
5000    2.22    2.47
6000    3.43    3.49
7000    5.01    4.84
8000    6.11    6.21
9000    7.75    7.74
10000   10.01   9.9
```

---
