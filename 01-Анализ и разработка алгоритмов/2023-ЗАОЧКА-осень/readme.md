# Что нужно сделать к следующей сессии чтобы сдать дисциплину АиРА:  

---  

## 1. Задачи для самостоятельного исполнения с прошлой сессии:  

1) На вход целое число: 23007, на выход - его поразрядно представление: 20000 + 3000 + 7  
-  желательно решить в ФУНКЦИОНАЛЬНОМ СТИЛЕ - код в одну строку (функции в цепочку, с переносами по точке)  

2) Даны две стороны прямоугольника. Требуется найти минимальное кол-во квадратов, которыми можно заполнить этот прямоугольник. Квадраты могут быть разной величины.  
- желательно решить с помощью РЕКУРСИИ  

3) Дан отсортированный массив целых чисел из диапазона [-1000; +1000]. Найти пару чисел в сумме дающих заданное число.  
- желательно решить за линейное время - без полного перебора  
тут можно проверить: https://leetcode.com/problems/two-sum/  

---  

## 2. Принести решения Задачи о заполнении рюкзака, которые я сам писал во время наших занятий  

- видеозаписи все сохранены в кабинете для онлайн-занятий  
- знать, уметь объяснить, иметь при себе в день сдачи - вот эти решения:  

> жадный алгоритм  
> бинарные маски  
> рекурсия  

---  

## 3. ЗАДАЧИ для лабораторных занятий  

[Google-board по этой теме](https://jamboard.google.com/d/1vtwRSDglO_TcvXbpGJEq9rlKMU_sOyvbBmXsc76kkY8/edit?usp=sharing)  

### 3.1. Написать программную реализацию алгоритма поиска числа  

```txt
a: линейно 
b: бинарный поиск
c: бинарный поиск - рекурсивно
d: интерполяционный поиск
e: поиск в бинарном дереве (часть напишем на занятии, до конца самостоятельно)

- сравнить методы (a,b,c,d,e) по количеству шагов, по времени  
- объяснить разницу  
```

### 3.2. Написать программную реализацию алгоритма поиска слова  

- дан список слов русского языка (words_utf.txt)  
- дан список слов, позицию которых нужно найти (find_words.txt)  
- реализовать линейный и бинарный поиск в списке слов русского языка (лежат в папке find_words)  
- сравнить по количеству шагов поиска  
- почему бинарный поиск не может найти слова: як, яхта  
- исправить этот баг  

---  

---  

Дальше просто некоторые пояснения...  

Дерево можно построить на:  

- на основе словарей  
- на основе класса Node  
- ассоциативном массиве  

```py
node5 = {
    "key": 5,
    "left": None,
    "right": None
}
node3 = {
    "key": 3,
    "left": None,
    "right": node5
}


class Node:
    def __init__(self, key):
        self.key = key  # вершина - родитель
        self.left = None
        self.right = None
```

BFS - Breadth-First Search - поиск в ширину (когда цель близко) - Queue - FIFO  
DFS - Deep-First Search - поиск в глубину (когда цель далеко) - Stack - LIFO; Recurse  

---  
