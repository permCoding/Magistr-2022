def swap(t, i, j): t[i], t[j] = t[j], t[i]

def get_heap(t):  # из массива получить максимальную кучу
    # на вершине максимальной куче - максимальный элемент
    # в тройке родитель и дети - максимальный всегда наверху
    # если родитель i, то дети: 2*i+1 и 2*i+2
    # heap = [7, 4, 5, 3, 1, 2]  # пока просто готовая куча
    heap = [95, 70, 27, 67, 32, 16, 24, 19, 64, 21]
    return heap

def get_sorted(arr):
    def down_elm(n):  # опускаем эл-нт с вершины по правилу кучи
        i = 0  # индекс родителя и 2*i+1; 2*i+2 - индексы детей
        while 2*i+1 < n:  # пока ещё есть куда опускать
            ch_1 = arr[2*i+1]  # первый дитя
            ch_2 = arr[2*i+2] if 2*i+2 < n else -float('inf')
            fam = [ [arr[i],i], [ch_1,2*i+1], [ch_2,2*i+2] ]
            max_pos = max(fam)[1]  # выбираем из трёх - max
            if i == max_pos: break  # дальше опускать не требуется
            swap(arr, i, max_pos)  # меняем род-ля и дитя местами
            i = max_pos  # новая позиция опускаемого эл-та
    
    n = len(arr)  # размер оставшейся неотсорт-нной части массива
    while n > 1:  # каждый текущий последний
        swap(arr, 0, n-1)  # переставить на вершину кучи
        n -= 1  # сократить размер
        down_elm(n)  # элемент с вершины опустить по правилу кучи
    return arr  # вернуть отсортированный массив

arr = []  # тут будет несортированный массив
heap = get_heap(arr)  # из массива получаем кучу
print(heap)  # это для контроля
srt = get_sorted(heap)  # из кучи получаем отсортированный массив
print(srt)

"""
https://ru.wikipedia.org/wiki/Куча_(структура_данных)
Кучи обычно реализуются в виде массивов, 
что исключает наличие указателей между её элементами.
"""