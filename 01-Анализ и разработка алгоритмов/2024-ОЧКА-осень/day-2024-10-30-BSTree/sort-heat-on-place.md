# SORT HEAP  

Используется бинарное дерево поиска (BST), которое соответствует правилу:  
- для каждого узла верно  
  - у узла не более двух потомков  
  - левый потомок меньше, правый - больше  

Для бинарного дерева следует создать методы:  
- добавление элемента  
- удаление элемента  
- поиск элемента  
- упорядоченный вывод всех элементов  
- вывод в виде дерева (графически - с уровнями и отступами)  

---  

**Удаление** узла из бинарного дерева поиска.  

В этом методе требуется удалить элемент так, чтобы сохранить свойства дерева.  

Так как известно, что значение каждого узла больше, чем значения всех узлов в его левом поддереве, и меньше, чем значения всех узлов в его правом поддереве, то при удалении узла на его место можно поставить минимальный узел из правого поддерева (это гарантирует, что он окажется больше, чем все из левого и меньше, чем все из правого) ЛИБО максимальный из левого поддерева (можно выбрать только один из двух подходов, сразу оба в программе не требуется реализовывать).  

Не всегда у узла (родителя) имеется сразу два потомка.  
Если потомок один, то его и ставим на место удаляемого.  
Если потомков нет (это ЛИСТ дерева), то на его место ставим None (null).  

Рассмотрим основные шаги для удаления узла из BST:

1. На вход подаётся значение, которое следует удалить из дерева.  

2. Осуществляем рекурсивный спуск по дереву (поиск по дереву) в поисках узла для удаления.  

3. Проверяем условия для удаления:  

  3.1. Если узел не имеет потомков, то в просто удаляем узел, изменив указатель родительского узла на None.  

  3.2. Если узел имеет одного ребенка, то заменяем удаляемый узел его единственным дочерним узлом.  

  3.3. Если узел имеет двух детей, то в наличии два поддерева с элементами. Все элементы слева гарантированно меньше значения удаляемого узла, все элементы справа - больше. Следовательно, можно, например, в правом поддереве найти МИНИМАЛЬНЫЙ элемент и поставить его на место удаляемого узла. Тогда получится, что все элементы слева будут меньше обновлённого значения в удаляемом узле и все элементы справа - больше. Свойство дерева сохранится.

---  


```py
    def delete(self, value):
        self.root = self._delete(self.root, value)

    def _delete(self, node, key):
        if node is None: return node

        if key < node.val:  # Поиск узла для удаления слева или справа
            node.left = self._delete(node.left, key)
        elif key > node.val:
            node.right = self._delete(node.right, key)
        else:  # нашли узел - удаляем его
            
            if node.left is None:  # если узел с 1 или 0 потомков
                return node.right
            elif node.right is None:
                return node.left
            
            # узел с двумя потомками
            min_right = self._min_right(node.right)  # наименьший узел в правом поддереве
            node.val = min_right.val  # ставим на место удаляемого
            node.right = self._delete(node.right, min_right.val)  # рекурсивно удаляем наименьший

        return node  # возвращаем изменённое дерево

    def _min_right(self, node):
        current = node
        while current.left is not None:
            current = current.left
        return current
```

---  

Бинарный поиск в упорядоченнос массиве - O(log N).  
Поиск в BST - O(log N).  

Но вставка и удаление значения:  

- в упорядоченном массиве занимает O(N) времени, потому что помимо поиска мы должны сдвинуть много данных вправо (чтобы освободить место для вставляемого значения) или влево (чтобы занять место удаляемого).

- в BST - O(log N).  

Именно это делает двоичные деревья поиска такими эффективными. В то время как временная сложность поиска в упорядоченных массивах — O(log N), а вставки — O(N), временная сложность поиска и вставки в двоичных деревьях поиска — O(log N). Это очень важно для приложения, где часто приходится менять данные.  

---  